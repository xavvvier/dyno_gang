/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};\n\n    function n(i) {\n      if (t[i]) return t[i].exports;\n      var o = t[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var i = Object.create(null);\n      if (n.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(i, o, function (t) {\n        return e[t];\n      }.bind(null, o));\n      return i;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 0);\n  }([function (e, t, n) {\n    (function (t) {\n      e.exports = t.Phoenix = n(2);\n    }).call(this, n(1));\n  }, function (e, t) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || new Function(\"return this\")();\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    e.exports = n;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    function i(e) {\n      return function (e) {\n        if (Array.isArray(e)) return a(e);\n      }(e) || function (e) {\n        if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\n      }(e) || s(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function o(e) {\n      return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function r(e, t) {\n      return function (e) {\n        if (Array.isArray(e)) return e;\n      }(e) || function (e, t) {\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\n        var n = [],\n            i = !0,\n            o = !1,\n            r = void 0;\n\n        try {\n          for (var s, a = e[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); i = !0);\n        } catch (e) {\n          o = !0, r = e;\n        } finally {\n          try {\n            i || null == a.return || a.return();\n          } finally {\n            if (o) throw r;\n          }\n        }\n\n        return n;\n      }(e, t) || s(e, t) || function () {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function s(e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return a(e, t);\n        var n = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(n) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;\n      }\n    }\n\n    function a(e, t) {\n      (null == t || t > e.length) && (t = e.length);\n\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n\n      return i;\n    }\n\n    function c(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function u(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var i = t[n];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n      }\n    }\n\n    function h(e, t, n) {\n      return t && u(e.prototype, t), n && u(e, n), e;\n    }\n\n    n.r(t), n.d(t, \"Channel\", function () {\n      return _;\n    }), n.d(t, \"Serializer\", function () {\n      return H;\n    }), n.d(t, \"Socket\", function () {\n      return U;\n    }), n.d(t, \"LongPoll\", function () {\n      return D;\n    }), n.d(t, \"Ajax\", function () {\n      return M;\n    }), n.d(t, \"Presence\", function () {\n      return N;\n    });\n\n    var l = \"undefined\" != typeof self ? self : null,\n        f = \"undefined\" != typeof window ? window : null,\n        d = l || f || void 0,\n        p = 0,\n        v = 1,\n        y = 2,\n        m = 3,\n        g = \"closed\",\n        k = \"errored\",\n        b = \"joined\",\n        j = \"joining\",\n        T = \"leaving\",\n        C = \"phx_close\",\n        R = \"phx_error\",\n        E = \"phx_join\",\n        w = \"phx_reply\",\n        S = \"phx_leave\",\n        A = [C, R, E, w, S],\n        L = \"longpoll\",\n        x = \"websocket\",\n        O = function (e) {\n      if (\"function\" == typeof e) return e;\n      return function () {\n        return e;\n      };\n    },\n        P = function () {\n      function e(t, n, i, o) {\n        c(this, e), this.channel = t, this.event = n, this.payload = i || function () {\n          return {};\n        }, this.receivedResp = null, this.timeout = o, this.timeoutTimer = null, this.recHooks = [], this.sent = !1;\n      }\n\n      return h(e, [{\n        key: \"resend\",\n        value: function (e) {\n          this.timeout = e, this.reset(), this.send();\n        }\n      }, {\n        key: \"send\",\n        value: function () {\n          this.hasReceived(\"timeout\") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload(),\n            ref: this.ref,\n            join_ref: this.channel.joinRef()\n          }));\n        }\n      }, {\n        key: \"receive\",\n        value: function (e, t) {\n          return this.hasReceived(e) && t(this.receivedResp.response), this.recHooks.push({\n            status: e,\n            callback: t\n          }), this;\n        }\n      }, {\n        key: \"reset\",\n        value: function () {\n          this.cancelRefEvent(), this.ref = null, this.refEvent = null, this.receivedResp = null, this.sent = !1;\n        }\n      }, {\n        key: \"matchReceive\",\n        value: function (e) {\n          var t = e.status,\n              n = e.response;\n          e.ref;\n          this.recHooks.filter(function (e) {\n            return e.status === t;\n          }).forEach(function (e) {\n            return e.callback(n);\n          });\n        }\n      }, {\n        key: \"cancelRefEvent\",\n        value: function () {\n          this.refEvent && this.channel.off(this.refEvent);\n        }\n      }, {\n        key: \"cancelTimeout\",\n        value: function () {\n          clearTimeout(this.timeoutTimer), this.timeoutTimer = null;\n        }\n      }, {\n        key: \"startTimeout\",\n        value: function () {\n          var e = this;\n          this.timeoutTimer && this.cancelTimeout(), this.ref = this.channel.socket.makeRef(), this.refEvent = this.channel.replyEventName(this.ref), this.channel.on(this.refEvent, function (t) {\n            e.cancelRefEvent(), e.cancelTimeout(), e.receivedResp = t, e.matchReceive(t);\n          }), this.timeoutTimer = setTimeout(function () {\n            e.trigger(\"timeout\", {});\n          }, this.timeout);\n        }\n      }, {\n        key: \"hasReceived\",\n        value: function (e) {\n          return this.receivedResp && this.receivedResp.status === e;\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t) {\n          this.channel.trigger(this.refEvent, {\n            status: e,\n            response: t\n          });\n        }\n      }]), e;\n    }(),\n        _ = function () {\n      function e(t, n, i) {\n        var o = this;\n        c(this, e), this.state = g, this.topic = t, this.params = O(n || {}), this.socket = i, this.bindings = [], this.bindingRef = 0, this.timeout = this.socket.timeout, this.joinedOnce = !1, this.joinPush = new P(this, E, this.params, this.timeout), this.pushBuffer = [], this.stateChangeRefs = [], this.rejoinTimer = new J(function () {\n          o.socket.isConnected() && o.rejoin();\n        }, this.socket.rejoinAfterMs), this.stateChangeRefs.push(this.socket.onError(function () {\n          return o.rejoinTimer.reset();\n        })), this.stateChangeRefs.push(this.socket.onOpen(function () {\n          o.rejoinTimer.reset(), o.isErrored() && o.rejoin();\n        })), this.joinPush.receive(\"ok\", function () {\n          o.state = b, o.rejoinTimer.reset(), o.pushBuffer.forEach(function (e) {\n            return e.send();\n          }), o.pushBuffer = [];\n        }), this.joinPush.receive(\"error\", function () {\n          o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.onClose(function () {\n          o.rejoinTimer.reset(), o.socket.hasLogger() && o.socket.log(\"channel\", \"close \".concat(o.topic, \" \").concat(o.joinRef())), o.state = g, o.socket.remove(o);\n        }), this.onError(function (e) {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"error \".concat(o.topic), e), o.isJoining() && o.joinPush.reset(), o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.joinPush.receive(\"timeout\", function () {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"timeout \".concat(o.topic, \" (\").concat(o.joinRef(), \")\"), o.joinPush.timeout), new P(o, S, O({}), o.timeout).send(), o.state = k, o.joinPush.reset(), o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.on(w, function (e, t) {\n          o.trigger(o.replyEventName(t), e);\n        });\n      }\n\n      return h(e, [{\n        key: \"join\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          if (this.joinedOnce) throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n          return this.timeout = e, this.joinedOnce = !0, this.rejoin(), this.joinPush;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          this.on(C, e);\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          return this.on(R, function (t) {\n            return e(t);\n          });\n        }\n      }, {\n        key: \"on\",\n        value: function (e, t) {\n          var n = this.bindingRef++;\n          return this.bindings.push({\n            event: e,\n            ref: n,\n            callback: t\n          }), n;\n        }\n      }, {\n        key: \"off\",\n        value: function (e, t) {\n          this.bindings = this.bindings.filter(function (n) {\n            return !(n.event === e && (void 0 === t || t === n.ref));\n          });\n        }\n      }, {\n        key: \"canPush\",\n        value: function () {\n          return this.socket.isConnected() && this.isJoined();\n        }\n      }, {\n        key: \"push\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.timeout;\n          if (t = t || {}, !this.joinedOnce) throw new Error(\"tried to push '\".concat(e, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));\n          var i = new P(this, e, function () {\n            return t;\n          }, n);\n          return this.canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i;\n        }\n      }, {\n        key: \"leave\",\n        value: function () {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.rejoinTimer.reset(), this.joinPush.cancelTimeout(), this.state = T;\n\n          var n = function () {\n            e.socket.hasLogger() && e.socket.log(\"channel\", \"leave \".concat(e.topic)), e.trigger(C, \"leave\");\n          },\n              i = new P(this, S, O({}), t);\n\n          return i.receive(\"ok\", function () {\n            return n();\n          }).receive(\"timeout\", function () {\n            return n();\n          }), i.send(), this.canPush() || i.trigger(\"ok\", {}), i;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e, t, n) {\n          return t;\n        }\n      }, {\n        key: \"isLifecycleEvent\",\n        value: function (e) {\n          return A.indexOf(e) >= 0;\n        }\n      }, {\n        key: \"isMember\",\n        value: function (e, t, n, i) {\n          return this.topic === e && (!i || i === this.joinRef() || !this.isLifecycleEvent(t) || (this.socket.hasLogger() && this.socket.log(\"channel\", \"dropping outdated message\", {\n            topic: e,\n            event: t,\n            payload: n,\n            joinRef: i\n          }), !1));\n        }\n      }, {\n        key: \"joinRef\",\n        value: function () {\n          return this.joinPush.ref;\n        }\n      }, {\n        key: \"rejoin\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.isLeaving() || (this.socket.leaveOpenTopic(this.topic), this.state = j, this.joinPush.resend(e));\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t, n, i) {\n          var o = this.onMessage(e, t, n, i);\n          if (t && !o) throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n\n          for (var r = this.bindings.filter(function (t) {\n            return t.event === e;\n          }), s = 0; s < r.length; s++) {\n            r[s].callback(o, n, i || this.joinRef());\n          }\n        }\n      }, {\n        key: \"replyEventName\",\n        value: function (e) {\n          return \"chan_reply_\".concat(e);\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this.state === g;\n        }\n      }, {\n        key: \"isErrored\",\n        value: function () {\n          return this.state === k;\n        }\n      }, {\n        key: \"isJoined\",\n        value: function () {\n          return this.state === b;\n        }\n      }, {\n        key: \"isJoining\",\n        value: function () {\n          return this.state === j;\n        }\n      }, {\n        key: \"isLeaving\",\n        value: function () {\n          return this.state === T;\n        }\n      }]), e;\n    }(),\n        H = {\n      HEADER_LENGTH: 1,\n      META_LENGTH: 4,\n      KINDS: {\n        push: 0,\n        reply: 1,\n        broadcast: 2\n      },\n      encode: function (e, t) {\n        if (e.payload.constructor === ArrayBuffer) return t(this.binaryEncode(e));\n        var n = [e.join_ref, e.ref, e.topic, e.event, e.payload];\n        return t(JSON.stringify(n));\n      },\n      decode: function (e, t) {\n        if (e.constructor === ArrayBuffer) return t(this.binaryDecode(e));\n        var n = r(JSON.parse(e), 5);\n        return t({\n          join_ref: n[0],\n          ref: n[1],\n          topic: n[2],\n          event: n[3],\n          payload: n[4]\n        });\n      },\n      binaryEncode: function (e) {\n        var t = e.join_ref,\n            n = e.ref,\n            i = e.event,\n            o = e.topic,\n            r = e.payload,\n            s = this.META_LENGTH + t.length + n.length + o.length + i.length,\n            a = new ArrayBuffer(this.HEADER_LENGTH + s),\n            c = new DataView(a),\n            u = 0;\n        c.setUint8(u++, this.KINDS.push), c.setUint8(u++, t.length), c.setUint8(u++, n.length), c.setUint8(u++, o.length), c.setUint8(u++, i.length), Array.from(t, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(n, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(o, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(i, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        });\n        var h = new Uint8Array(a.byteLength + r.byteLength);\n        return h.set(new Uint8Array(a), 0), h.set(new Uint8Array(r), a.byteLength), h.buffer;\n      },\n      binaryDecode: function (e) {\n        var t = new DataView(e),\n            n = t.getUint8(0),\n            i = new TextDecoder();\n\n        switch (n) {\n          case this.KINDS.push:\n            return this.decodePush(e, t, i);\n\n          case this.KINDS.reply:\n            return this.decodeReply(e, t, i);\n\n          case this.KINDS.broadcast:\n            return this.decodeBroadcast(e, t, i);\n        }\n      },\n      decodePush: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = t.getUint8(3),\n            s = this.HEADER_LENGTH + this.META_LENGTH - 1,\n            a = n.decode(e.slice(s, s + i));\n        s += i;\n        var c = n.decode(e.slice(s, s + o));\n        s += o;\n        var u = n.decode(e.slice(s, s + r));\n        return s += r, {\n          join_ref: a,\n          ref: null,\n          topic: c,\n          event: u,\n          payload: e.slice(s, e.byteLength)\n        };\n      },\n      decodeReply: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = t.getUint8(3),\n            s = t.getUint8(4),\n            a = this.HEADER_LENGTH + this.META_LENGTH,\n            c = n.decode(e.slice(a, a + i));\n        a += i;\n        var u = n.decode(e.slice(a, a + o));\n        a += o;\n        var h = n.decode(e.slice(a, a + r));\n        a += r;\n        var l = n.decode(e.slice(a, a + s));\n        a += s;\n        var f = e.slice(a, e.byteLength);\n        return {\n          join_ref: c,\n          ref: u,\n          topic: h,\n          event: w,\n          payload: {\n            status: l,\n            response: f\n          }\n        };\n      },\n      decodeBroadcast: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = this.HEADER_LENGTH + 2,\n            s = n.decode(e.slice(r, r + i));\n        r += i;\n        var a = n.decode(e.slice(r, r + o));\n        return r += o, {\n          join_ref: null,\n          ref: null,\n          topic: s,\n          event: a,\n          payload: e.slice(r, e.byteLength)\n        };\n      }\n    },\n        U = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e), this.stateChangeCallbacks = {\n          open: [],\n          close: [],\n          error: [],\n          message: []\n        }, this.channels = [], this.sendBuffer = [], this.ref = 0, this.timeout = i.timeout || 1e4, this.transport = i.transport || d.WebSocket || D, this.defaultEncoder = H.encode.bind(H), this.defaultDecoder = H.decode.bind(H), this.closeWasClean = !1, this.unloaded = !1, this.binaryType = i.binaryType || \"arraybuffer\", this.transport !== D ? (this.encode = i.encode || this.defaultEncoder, this.decode = i.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder, this.decode = this.defaultDecoder), f && f.addEventListener && f.addEventListener(\"beforeunload\", function (e) {\n          n.conn && (n.unloaded = !0, n.abnormalClose(\"unloaded\"));\n        }), this.heartbeatIntervalMs = i.heartbeatIntervalMs || 3e4, this.rejoinAfterMs = function (e) {\n          return i.rejoinAfterMs ? i.rejoinAfterMs(e) : [1e3, 2e3, 5e3][e - 1] || 1e4;\n        }, this.reconnectAfterMs = function (e) {\n          return n.unloaded ? 100 : i.reconnectAfterMs ? i.reconnectAfterMs(e) : [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][e - 1] || 5e3;\n        }, this.logger = i.logger || null, this.longpollerTimeout = i.longpollerTimeout || 2e4, this.params = O(i.params || {}), this.endPoint = \"\".concat(t, \"/\").concat(x), this.vsn = i.vsn || \"2.0.0\", this.heartbeatTimer = null, this.pendingHeartbeatRef = null, this.reconnectTimer = new J(function () {\n          n.teardown(function () {\n            return n.connect();\n          });\n        }, this.reconnectAfterMs);\n      }\n\n      return h(e, [{\n        key: \"protocol\",\n        value: function () {\n          return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n        }\n      }, {\n        key: \"endPointURL\",\n        value: function () {\n          var e = M.appendParams(M.appendParams(this.endPoint, this.params()), {\n            vsn: this.vsn\n          });\n          return \"/\" !== e.charAt(0) ? e : \"/\" === e.charAt(1) ? \"\".concat(this.protocol(), \":\").concat(e) : \"\".concat(this.protocol(), \"://\").concat(location.host).concat(e);\n        }\n      }, {\n        key: \"disconnect\",\n        value: function (e, t, n) {\n          this.closeWasClean = !0, this.reconnectTimer.reset(), this.teardown(e, t, n);\n        }\n      }, {\n        key: \"connect\",\n        value: function (e) {\n          var t = this;\n          e && (console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\"), this.params = O(e)), this.conn || (this.closeWasClean = !1, this.conn = new this.transport(this.endPointURL()), this.conn.binaryType = this.binaryType, this.conn.timeout = this.longpollerTimeout, this.conn.onopen = function () {\n            return t.onConnOpen();\n          }, this.conn.onerror = function (e) {\n            return t.onConnError(e);\n          }, this.conn.onmessage = function (e) {\n            return t.onConnMessage(e);\n          }, this.conn.onclose = function (e) {\n            return t.onConnClose(e);\n          });\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t, n) {\n          this.logger(e, t, n);\n        }\n      }, {\n        key: \"hasLogger\",\n        value: function () {\n          return null !== this.logger;\n        }\n      }, {\n        key: \"onOpen\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.open.push([t, e]), t;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.close.push([t, e]), t;\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.error.push([t, e]), t;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.message.push([t, e]), t;\n        }\n      }, {\n        key: \"onConnOpen\",\n        value: function () {\n          this.hasLogger() && this.log(\"transport\", \"connected to \".concat(this.endPointURL())), this.unloaded = !1, this.closeWasClean = !1, this.flushSendBuffer(), this.reconnectTimer.reset(), this.resetHeartbeat(), this.stateChangeCallbacks.open.forEach(function (e) {\n            return (0, r(e, 2)[1])();\n          });\n        }\n      }, {\n        key: \"heartbeatTimeout\",\n        value: function () {\n          this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null, this.hasLogger() && this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\"), this.abnormalClose(\"heartbeat timeout\"));\n        }\n      }, {\n        key: \"resetHeartbeat\",\n        value: function () {\n          var e = this;\n          this.conn && this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null, clearTimeout(this.heartbeatTimer), setTimeout(function () {\n            return e.sendHeartbeat();\n          }, this.heartbeatIntervalMs));\n        }\n      }, {\n        key: \"teardown\",\n        value: function (e, t, n) {\n          var i = this;\n          if (!this.conn) return e && e();\n          this.waitForBufferDone(function () {\n            i.conn && (t ? i.conn.close(t, n || \"\") : i.conn.close()), i.waitForSocketClosed(function () {\n              i.conn && (i.conn.onclose = function () {}, i.conn = null), e && e();\n            });\n          });\n        }\n      }, {\n        key: \"waitForBufferDone\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.bufferedAmount ? setTimeout(function () {\n            t.waitForBufferDone(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"waitForSocketClosed\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.readyState !== m ? setTimeout(function () {\n            t.waitForSocketClosed(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"onConnClose\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", \"close\", e), this.triggerChanError(), clearTimeout(this.heartbeatTimer), this.closeWasClean || this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"onConnError\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", e), this.triggerChanError(), this.stateChangeCallbacks.error.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"triggerChanError\",\n        value: function () {\n          this.channels.forEach(function (e) {\n            e.isErrored() || e.isLeaving() || e.isClosed() || e.trigger(R);\n          });\n        }\n      }, {\n        key: \"connectionState\",\n        value: function () {\n          switch (this.conn && this.conn.readyState) {\n            case p:\n              return \"connecting\";\n\n            case v:\n              return \"open\";\n\n            case y:\n              return \"closing\";\n\n            default:\n              return \"closed\";\n          }\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return \"open\" === this.connectionState();\n        }\n      }, {\n        key: \"remove\",\n        value: function (e) {\n          this.off(e.stateChangeRefs), this.channels = this.channels.filter(function (t) {\n            return t.joinRef() !== e.joinRef();\n          });\n        }\n      }, {\n        key: \"off\",\n        value: function (e) {\n          for (var t in this.stateChangeCallbacks) this.stateChangeCallbacks[t] = this.stateChangeCallbacks[t].filter(function (t) {\n            var n = r(t, 1)[0];\n            return -1 === e.indexOf(n);\n          });\n        }\n      }, {\n        key: \"channel\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = new _(e, t, this);\n          return this.channels.push(n), n;\n        }\n      }, {\n        key: \"push\",\n        value: function (e) {\n          var t = this;\n\n          if (this.hasLogger()) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                r = e.ref,\n                s = e.join_ref;\n            this.log(\"push\", \"\".concat(n, \" \").concat(i, \" (\").concat(s, \", \").concat(r, \")\"), o);\n          }\n\n          this.isConnected() ? this.encode(e, function (e) {\n            return t.conn.send(e);\n          }) : this.sendBuffer.push(function () {\n            return t.encode(e, function (e) {\n              return t.conn.send(e);\n            });\n          });\n        }\n      }, {\n        key: \"makeRef\",\n        value: function () {\n          var e = this.ref + 1;\n          return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();\n        }\n      }, {\n        key: \"sendHeartbeat\",\n        value: function () {\n          var e = this;\n          this.pendingHeartbeatRef && !this.isConnected() || (this.pendingHeartbeatRef = this.makeRef(), this.push({\n            topic: \"phoenix\",\n            event: \"heartbeat\",\n            payload: {},\n            ref: this.pendingHeartbeatRef\n          }), this.heartbeatTimer = setTimeout(function () {\n            return e.heartbeatTimeout();\n          }, this.heartbeatIntervalMs));\n        }\n      }, {\n        key: \"abnormalClose\",\n        value: function (e) {\n          this.closeWasClean = !1, this.isConnected() && this.conn.close(1e3, e);\n        }\n      }, {\n        key: \"flushSendBuffer\",\n        value: function () {\n          this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(function (e) {\n            return e();\n          }), this.sendBuffer = []);\n        }\n      }, {\n        key: \"onConnMessage\",\n        value: function (e) {\n          var t = this;\n          this.decode(e.data, function (e) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                s = e.ref,\n                a = e.join_ref;\n            s && s === t.pendingHeartbeatRef && (clearTimeout(t.heartbeatTimer), t.pendingHeartbeatRef = null, setTimeout(function () {\n              return t.sendHeartbeat();\n            }, t.heartbeatIntervalMs)), t.hasLogger() && t.log(\"receive\", \"\".concat(o.status || \"\", \" \").concat(n, \" \").concat(i, \" \").concat(s && \"(\" + s + \")\" || \"\"), o);\n\n            for (var c = 0; c < t.channels.length; c++) {\n              var u = t.channels[c];\n              u.isMember(n, i, o, a) && u.trigger(i, o, s, a);\n            }\n\n            for (var h = 0; h < t.stateChangeCallbacks.message.length; h++) {\n              (0, r(t.stateChangeCallbacks.message[h], 2)[1])(e);\n            }\n          });\n        }\n      }, {\n        key: \"leaveOpenTopic\",\n        value: function (e) {\n          var t = this.channels.find(function (t) {\n            return t.topic === e && (t.isJoined() || t.isJoining());\n          });\n          t && (this.hasLogger() && this.log(\"transport\", 'leaving duplicate topic \"'.concat(e, '\"')), t.leave());\n        }\n      }]), e;\n    }(),\n        D = function () {\n      function e(t) {\n        c(this, e), this.endPoint = null, this.token = null, this.skipHeartbeat = !0, this.onopen = function () {}, this.onerror = function () {}, this.onmessage = function () {}, this.onclose = function () {}, this.pollEndpoint = this.normalizeEndpoint(t), this.readyState = p, this.poll();\n      }\n\n      return h(e, [{\n        key: \"normalizeEndpoint\",\n        value: function (e) {\n          return e.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + x), \"$1/\" + L);\n        }\n      }, {\n        key: \"endpointURL\",\n        value: function () {\n          return M.appendParams(this.pollEndpoint, {\n            token: this.token\n          });\n        }\n      }, {\n        key: \"closeAndRetry\",\n        value: function () {\n          this.close(), this.readyState = p;\n        }\n      }, {\n        key: \"ontimeout\",\n        value: function () {\n          this.onerror(\"timeout\"), this.closeAndRetry();\n        }\n      }, {\n        key: \"poll\",\n        value: function () {\n          var e = this;\n          this.readyState !== v && this.readyState !== p || M.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (t) {\n            if (t) {\n              var n = t.status,\n                  i = t.token,\n                  o = t.messages;\n              e.token = i;\n            } else n = 0;\n\n            switch (n) {\n              case 200:\n                o.forEach(function (t) {\n                  setTimeout(function () {\n                    e.onmessage({\n                      data: t\n                    });\n                  }, 0);\n                }), e.poll();\n                break;\n\n              case 204:\n                e.poll();\n                break;\n\n              case 410:\n                e.readyState = v, e.onopen(), e.poll();\n                break;\n\n              case 403:\n                e.onerror(), e.close();\n                break;\n\n              case 0:\n              case 500:\n                e.onerror(), e.closeAndRetry();\n                break;\n\n              default:\n                throw new Error(\"unhandled poll status \".concat(n));\n            }\n          });\n        }\n      }, {\n        key: \"send\",\n        value: function (e) {\n          var t = this;\n          M.request(\"POST\", this.endpointURL(), \"application/json\", e, this.timeout, this.onerror.bind(this, \"timeout\"), function (e) {\n            e && 200 === e.status || (t.onerror(e && e.status), t.closeAndRetry());\n          });\n        }\n      }, {\n        key: \"close\",\n        value: function (e, t) {\n          this.readyState = m, this.onclose();\n        }\n      }]), e;\n    }(),\n        M = function () {\n      function e() {\n        c(this, e);\n      }\n\n      return h(e, null, [{\n        key: \"request\",\n        value: function (e, t, n, i, o, r, s) {\n          if (d.XDomainRequest) {\n            var a = new XDomainRequest();\n            this.xdomainRequest(a, e, t, i, o, r, s);\n          } else {\n            var c = new d.XMLHttpRequest();\n            this.xhrRequest(c, e, t, n, i, o, r, s);\n          }\n        }\n      }, {\n        key: \"xdomainRequest\",\n        value: function (e, t, n, i, o, r, s) {\n          var a = this;\n          e.timeout = o, e.open(t, n), e.onload = function () {\n            var t = a.parseJSON(e.responseText);\n            s && s(t);\n          }, r && (e.ontimeout = r), e.onprogress = function () {}, e.send(i);\n        }\n      }, {\n        key: \"xhrRequest\",\n        value: function (e, t, n, i, o, r, s, a) {\n          var c = this;\n          e.open(t, n, !0), e.timeout = r, e.setRequestHeader(\"Content-Type\", i), e.onerror = function () {\n            a && a(null);\n          }, e.onreadystatechange = function () {\n            if (e.readyState === c.states.complete && a) {\n              var t = c.parseJSON(e.responseText);\n              a(t);\n            }\n          }, s && (e.ontimeout = s), e.send(o);\n        }\n      }, {\n        key: \"parseJSON\",\n        value: function (e) {\n          if (!e || \"\" === e) return null;\n\n          try {\n            return JSON.parse(e);\n          } catch (t) {\n            return console && console.log(\"failed to parse JSON response\", e), null;\n          }\n        }\n      }, {\n        key: \"serialize\",\n        value: function (e, t) {\n          var n = [];\n\n          for (var i in e) if (e.hasOwnProperty(i)) {\n            var r = t ? \"\".concat(t, \"[\").concat(i, \"]\") : i,\n                s = e[i];\n            \"object\" === o(s) ? n.push(this.serialize(s, r)) : n.push(encodeURIComponent(r) + \"=\" + encodeURIComponent(s));\n          }\n\n          return n.join(\"&\");\n        }\n      }, {\n        key: \"appendParams\",\n        value: function (e, t) {\n          if (0 === Object.keys(t).length) return e;\n          var n = e.match(/\\?/) ? \"&\" : \"?\";\n          return \"\".concat(e).concat(n).concat(this.serialize(t));\n        }\n      }]), e;\n    }();\n\n    M.states = {\n      complete: 4\n    };\n\n    var N = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e);\n        var o = i.events || {\n          state: \"presence_state\",\n          diff: \"presence_diff\"\n        };\n        this.state = {}, this.pendingDiffs = [], this.channel = t, this.joinRef = null, this.caller = {\n          onJoin: function () {},\n          onLeave: function () {},\n          onSync: function () {}\n        }, this.channel.on(o.state, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.joinRef = n.channel.joinRef(), n.state = e.syncState(n.state, t, o, r), n.pendingDiffs.forEach(function (t) {\n            n.state = e.syncDiff(n.state, t, o, r);\n          }), n.pendingDiffs = [], s();\n        }), this.channel.on(o.diff, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.inPendingSyncState() ? n.pendingDiffs.push(t) : (n.state = e.syncDiff(n.state, t, o, r), s());\n        });\n      }\n\n      return h(e, [{\n        key: \"onJoin\",\n        value: function (e) {\n          this.caller.onJoin = e;\n        }\n      }, {\n        key: \"onLeave\",\n        value: function (e) {\n          this.caller.onLeave = e;\n        }\n      }, {\n        key: \"onSync\",\n        value: function (e) {\n          this.caller.onSync = e;\n        }\n      }, {\n        key: \"list\",\n        value: function (t) {\n          return e.list(this.state, t);\n        }\n      }, {\n        key: \"inPendingSyncState\",\n        value: function () {\n          return !this.joinRef || this.joinRef !== this.channel.joinRef();\n        }\n      }], [{\n        key: \"syncState\",\n        value: function (e, t, n, i) {\n          var o = this,\n              r = this.clone(e),\n              s = {},\n              a = {};\n          return this.map(r, function (e, n) {\n            t[e] || (a[e] = n);\n          }), this.map(t, function (e, t) {\n            var n = r[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = n.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  u = t.metas.filter(function (e) {\n                return c.indexOf(e.phx_ref) < 0;\n              }),\n                  h = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              });\n              u.length > 0 && (s[e] = t, s[e].metas = u), h.length > 0 && (a[e] = o.clone(n), a[e].metas = h);\n            } else s[e] = t;\n          }), this.syncDiff(r, {\n            joins: s,\n            leaves: a\n          }, n, i);\n        }\n      }, {\n        key: \"syncDiff\",\n        value: function (e, t, n, o) {\n          var r = t.joins,\n              s = t.leaves,\n              a = this.clone(e);\n          return n || (n = function () {}), o || (o = function () {}), this.map(r, function (e, t) {\n            var o = a[e];\n\n            if (a[e] = t, o) {\n              var r,\n                  s = a[e].metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = o.metas.filter(function (e) {\n                return s.indexOf(e.phx_ref) < 0;\n              });\n              (r = a[e].metas).unshift.apply(r, i(c));\n            }\n\n            n(e, o, t);\n          }), this.map(s, function (e, t) {\n            var n = a[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              });\n              n.metas = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              }), o(e, n, t), 0 === n.metas.length && delete a[e];\n            }\n          }), a;\n        }\n      }, {\n        key: \"list\",\n        value: function (e, t) {\n          return t || (t = function (e, t) {\n            return t;\n          }), this.map(e, function (e, n) {\n            return t(e, n);\n          });\n        }\n      }, {\n        key: \"map\",\n        value: function (e, t) {\n          return Object.getOwnPropertyNames(e).map(function (n) {\n            return t(n, e[n]);\n          });\n        }\n      }, {\n        key: \"clone\",\n        value: function (e) {\n          return JSON.parse(JSON.stringify(e));\n        }\n      }]), e;\n    }(),\n        J = function () {\n      function e(t, n) {\n        c(this, e), this.callback = t, this.timerCalc = n, this.timer = null, this.tries = 0;\n      }\n\n      return h(e, [{\n        key: \"reset\",\n        value: function () {\n          this.tries = 0, clearTimeout(this.timer);\n        }\n      }, {\n        key: \"scheduleTimeout\",\n        value: function () {\n          var e = this;\n          clearTimeout(this.timer), this.timer = setTimeout(function () {\n            e.tries = e.tries + 1, e.callback();\n          }, this.timerCalc(this.tries + 1));\n        }\n      }]), e;\n    }();\n  }]);\n});\n\n//# sourceURL=webpack:///../deps/phoenix/priv/static/phoenix.js?");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();\n\n//# sourceURL=webpack:///../deps/phoenix_html/priv/static/phoenix_html.js?");

/***/ }),

/***/ "./css/app.css":
/*!*********************!*\
  !*** ./css/app.css ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./css/app.css?");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.css */ \"./css/app.css\");\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game */ \"./js/game.js\");\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keyboard */ \"./js/keyboard.js\");\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import dependencies\n//\n\n\n\n\nvar vueApp = new Vue({\n  el: '#userInput',\n  data: {\n    characters: ['virtualguy', 'pinkman', 'ninjafrog', 'maskdude'],\n    selected: 'virtualguy',\n    username: '',\n    visible: true,\n    error: ''\n  },\n  created: function created() {\n    var _this = this;\n\n    this.username = this.storeNameOrUuid();\n    this.up = Object(_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"keyboard\"])('ArrowUp'), this.down = Object(_keyboard__WEBPACK_IMPORTED_MODULE_3__[\"keyboard\"])('ArrowDown');\n\n    this.up.press = function () {\n      _this.selectPrevious();\n    };\n\n    this.down.press = function () {\n      _this.selectNext();\n    };\n  },\n  methods: {\n    storeNameOrUuid: function storeNameOrUuid() {\n      var storedName = localStorage.getItem('username');\n      if (storedName) return storedName;\n      return 'xxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0,\n            v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n      });\n    },\n    validate: function validate() {\n      var _this2 = this;\n\n      this.error = '';\n\n      if (this.username.trim() == '') {\n        this.error = 'Invalid name';\n        return;\n      }\n\n      var csrf = document.querySelector(\"meta[name='csrf-token']\").content;\n      var config = {\n        headers: {\n          'x-csrf-token': csrf\n        }\n      };\n      axios.post('validate', {\n        username: this.username\n      }, config).then(function (response) {\n        if (response.data.valid) {\n          window.userToken = response.data.token;\n          _this2.visible = false;\n          new _game__WEBPACK_IMPORTED_MODULE_2__[\"Game\"](document.getElementById('game'), {\n            width: 640,\n            height: 480\n          }, _this2.username, _this2.selected);\n          localStorage.setItem('username', _this2.username);\n\n          _this2.up.unsubscribe();\n\n          _this2.down.unsubscribe();\n        } else {\n          _this2.error = response.data.error;\n        }\n      })[\"catch\"](function (err) {\n        //If the csrf token is expired, a refresh might help\n        if (err.response.status == 403) {\n          window.location.reload(true);\n        }\n      });\n    },\n    selectPrevious: function selectPrevious() {\n      var selectedIndex = this.characters.indexOf(this.selected) - 1;\n      this.selected = this.characters[selectedIndex == -1 ? this.characters.length - 1 : selectedIndex];\n    },\n    selectNext: function selectNext() {\n      var selectedIndex = this.characters.indexOf(this.selected);\n      this.selected = this.characters[(selectedIndex + 1) % this.characters.length];\n    }\n  }\n});\n\n//# sourceURL=webpack:///./js/app.js?");

/***/ }),

/***/ "./js/game.js":
/*!********************!*\
  !*** ./js/game.js ***!
  \********************/
/*! exports provided: Game */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Game\", function() { return Game; });\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keyboard */ \"./js/keyboard.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./player */ \"./js/player.js\");\n/* harmony import */ var _ghost__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ghost */ \"./js/ghost.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n //Aliases\n\nvar Application = PIXI.Application,\n    Container = PIXI.Container,\n    Sprite = PIXI.Sprite,\n    loader = PIXI.Loader.shared,\n    Assets = {\n  virtualguy: 'images/virtualguy.json',\n  ninjafrog: 'images/ninjafrog.json',\n  maskdude: 'images/maskdude.json',\n  pinkman: 'images/pinkman.json',\n  background: 'images/backgrounds/stars_blue.png',\n  floor: 'images/floor.png',\n  obstacle1: 'images/fan.json',\n  obstacle2: 'images/fire.json',\n  obstacle3: 'images/rockhead.json',\n  obstacle4: 'images/spikehead.json'\n};\nvar Game =\n/*#__PURE__*/\nfunction () {\n  function Game(domElement, options, username, character) {\n    _classCallCheck(this, Game);\n\n    this.domElement = domElement;\n    this.options = options;\n    this.username = username;\n    this.character = character;\n    this.init();\n  }\n\n  _createClass(Game, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      //Create the pixi application\n      this.app = new Application({\n        width: this.options.width,\n        height: this.options.height\n      }); //Add the canvas to the document\n\n      this.domElement.appendChild(this.app.view); //Load assets\n\n      loader.add([Assets.virtualguy, Assets.ninjafrog, Assets.maskdude, Assets.pinkman, Assets.background, Assets.floor, Assets.obstacle1, Assets.obstacle2, Assets.obstacle3, Assets.obstacle4]).load(function () {\n        return _this.setup();\n      }); //Create the socket and connect to it\n\n      this.socket = new phoenix__WEBPACK_IMPORTED_MODULE_1__[\"Socket\"]('/socket', {\n        params: {\n          token: window.userToken\n        }\n      });\n      this.socket.connect();\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this2 = this;\n\n      this.channel = this.socket.channel('game:all', {\n        character: this.character\n      });\n      this.channel.join().receive('ok', function (resp) {\n        return _this2.onConnected(resp);\n      }).receive('error', function (resp) {\n        return console.log('Unable to join', resp);\n      });\n      var playerSprite = loader.resources[Assets[this.character]].spritesheet;\n      var bgTexture = loader.resources[Assets.background].texture;\n      var floorTexture = loader.resources[Assets.floor].texture; //Contains all the other players\n      //adding this container first will put other players behind the local player\n      //(added after setup initialization)\n\n      this.otherPlayersContainer = new Container(); //Contains all the elements in the stage\n\n      this.container = new Container();\n      this.app.stage.addChild(this.container);\n      this.bgSprite = new PIXI.TilingSprite(bgTexture, this.options.width, this.options.height);\n      this.floorSprite = new PIXI.TilingSprite(floorTexture, this.options.width, 47);\n      this.floorSprite.anchor.set(0, 1);\n      this.floorSprite.y = this.options.height;\n      this.container.addChild(this.bgSprite);\n      this.container.addChild(this.floorSprite);\n      this.container.addChild(this.otherPlayersContainer);\n      this.player = new _player__WEBPACK_IMPORTED_MODULE_2__[\"Player\"](playerSprite, this.container, this.options);\n      this.resetGameState();\n      this.keyBindings();\n\n      this.player.onJumpFinished = function () {\n        _this2.sendKey('up.release');\n      };\n\n      this.channelSubscribe();\n      this.gameLoop();\n    }\n  }, {\n    key: \"resetGameState\",\n    value: function resetGameState() {\n      this.score = 0;\n      this.isGameOver = false;\n      this.players = {}; //If there is previous obstacle (reset) remove them all\n\n      if (this.obstacles) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.obstacles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var obs = _step.value;\n            this.container.removeChild(obs);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      this.obstacles = []; //Remove previous score texts\n\n      if (this.scoreText) {\n        this.container.removeChild(this.scoreText);\n        this.container.removeChild(this.othersScoreText);\n        this.container.removeChild(this.maxScore);\n      }\n\n      if (this.gameResetText) {\n        this.container.removeChild(this.gameResetText);\n      }\n\n      this.drawScore();\n    }\n  }, {\n    key: \"channelSubscribe\",\n    value: function channelSubscribe() {\n      var _this3 = this;\n\n      //Suscribe to channel events\n      this.channel.on('player_move', function (data) {\n        _this3.gameAction(data.response);\n      });\n      this.channel.on('obstacle_event', function (data) {\n        _this3.onNewObstacle(data);\n      });\n      this.channel.on('player_joined', function (data) {\n        _this3.onPlayerJoin(data);\n      });\n      this.channel.on('player_left', function (data) {\n        _this3.onPlayerLeave(data);\n      });\n      this.channel.on('player_dead', function (data) {\n        _this3.onPlayerDead(data);\n      });\n    }\n  }, {\n    key: \"channelUnsubscribe\",\n    value: function channelUnsubscribe() {\n      //Unsuscribe from channel when no longer required (ie Game Over)\n      this.channel.off('player_move');\n      this.channel.off('obstacle_event');\n      this.channel.off('player_joined');\n      this.channel.off('player_left');\n      this.channel.off('player_dead');\n    }\n  }, {\n    key: \"drawScore\",\n    value: function drawScore() {\n      var opts = {\n        fontFamily: 'pixellari',\n        fontSize: 20,\n        fill: ['#ffffff', '#00ff99'],\n        dropShadow: true,\n        dropShadowColor: '#000000',\n        dropShadowBlur: 4,\n        dropShadowAngle: Math.PI / 6,\n        dropShadowDistance: 6,\n        align: 'right'\n      };\n      this.scoreText = new PIXI.Text(this.score, opts);\n      this.scoreText.x = 30;\n      this.scoreText.y = 30;\n      this.container.addChild(this.scoreText);\n      opts = {\n        fontFamily: 'pixellari',\n        fontSize: 15,\n        fill: ['#ffffff', '#82c4ec'],\n        align: 'right'\n      };\n      this.othersScoreText = new PIXI.Text('', opts);\n      this.othersScoreText.anchor.set(1, 0);\n      this.othersScoreText.x = this.options.width - 10;\n      this.othersScoreText.y = 35;\n      this.container.addChild(this.othersScoreText);\n      this.maxScore = new PIXI.Text('', {\n        fontSize: 10,\n        fill: '#ffffff'\n      });\n      this.maxScore.anchor.set(1, 0);\n      this.maxScore.y = 10;\n      this.maxScore.x = this.options.width - 10;\n      this.container.addChild(this.maxScore);\n    }\n  }, {\n    key: \"onConnected\",\n    value: function onConnected(resp) {\n      if (Object.keys(resp.players).length === 0) {\n        // There's only one player, let's create a ghost so you don't feel lonely\n        this.ghost = new _ghost__WEBPACK_IMPORTED_MODULE_3__[\"Ghost\"](this.channel);\n      } //render the players already playing\n\n\n      for (var player in resp.players) {\n        if (resp.players[player].alive) {\n          this.onPlayerJoin(resp.players[player]);\n        }\n      }\n    }\n  }, {\n    key: \"keyBindings\",\n    value: function keyBindings() {\n      var _this4 = this;\n\n      //Key binding\n      var left = Object(_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"keyboard\"])('ArrowLeft'),\n          right = Object(_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"keyboard\"])('ArrowRight'),\n          enter = Object(_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"keyboard\"])('Enter'),\n          up = Object(_keyboard__WEBPACK_IMPORTED_MODULE_0__[\"keyboard\"])('ArrowUp');\n\n      enter.press = function () {\n        _this4.restart();\n      };\n\n      up.press = function () {\n        _this4.sendKey('up.press');\n      };\n\n      right.press = function () {\n        _this4.sendKey('right.press');\n      };\n\n      right.release = function () {\n        _this4.sendKey('right.release');\n      };\n\n      left.press = function () {\n        _this4.sendKey('left.press');\n      };\n\n      left.release = function () {\n        _this4.sendKey('left.release');\n      };\n    }\n  }, {\n    key: \"onNewObstacle\",\n    value: function onNewObstacle(data) {\n      var types = [Assets.obstacle1, Assets.obstacle2, Assets.obstacle3, Assets.obstacle4];\n      var type = types[data.type - 1];\n      var spritesheet = loader.resources[type].spritesheet;\n      var obstacle = new PIXI.AnimatedSprite(spritesheet.animations[\"default\"]);\n      obstacle.animationSpeed = 0.1;\n      obstacle.anchor.set(0.5, 1);\n      obstacle.y = this.options.height - 50;\n      obstacle.x = this.options.width + obstacle.width;\n      this.container.addChild(obstacle);\n      this.obstacles.push(obstacle);\n      obstacle.play();\n    }\n  }, {\n    key: \"onPlayerJoin\",\n    value: function onPlayerJoin(data) {\n      if (data.name == this.username) {\n        return;\n      }\n\n      var playerSprite = loader.resources[Assets[data.character]].spritesheet;\n      var player = new _player__WEBPACK_IMPORTED_MODULE_2__[\"Player\"](playerSprite, this.otherPlayersContainer, this.options);\n      player.setTransparency();\n      this.players[data.name] = player; //If the player doesn't have a x position, this means someone else joined the game\n      //the user will be located in the initial default position.\n      //If the player does have a x position, it means we are joining the game\n      //and therefore we need to locate those players in their most recent position\n      //update the position based on the last action sent to the server\n\n      if (data.x) {\n        player.x = data.x;\n      }\n    }\n  }, {\n    key: \"onPlayerLeave\",\n    value: function onPlayerLeave(data) {\n      if (data.name in this.players) {\n        this.players[data.name].destroy();\n        delete this.players[data.name];\n      }\n    }\n  }, {\n    key: \"onPlayerDead\",\n    value: function onPlayerDead(data) {\n      if (data.name in this.players) {\n        //get reference of that player\n        var player = this.players[data.name];\n        player.dieAndTint();\n        setTimeout(function () {\n          player.destroy();\n        }, 1000);\n      }\n    }\n  }, {\n    key: \"gameAction\",\n    value: function gameAction(game_state) {\n      var movements = game_state.players;\n\n      if (this.isGameOver) {\n        return;\n      }\n\n      var player_move = movements[this.username]; //Move local player\n\n      this.player.move(player_move); //Move remote players and update score\n\n      var scores = [];\n\n      for (var player_name in movements) {\n        if (player_name !== this.username && player_name in this.players) {\n          this.players[player_name].move(movements[player_name]);\n        }\n\n        scores.push(movements[player_name]);\n      } //update score\n\n\n      scores.sort(function (a, b) {\n        return b.score - a.score;\n      });\n      var othersScore = scores.map(function (s) {\n        return s.name + ': ' + s.score + '\\n';\n      }).join('');\n      this.othersScoreText.text = othersScore;\n      var _game_state$max_score = game_state.max_score,\n          username = _game_state$max_score.username,\n          value = _game_state$max_score.value;\n      this.maxScore.text = 'Record: ' + username + ' ' + value;\n    }\n  }, {\n    key: \"collide\",\n    value: function collide(r1, r2) {\n      var margin = 7;\n\n      if (r1.x + r1.width - margin >= r2.x && // r1 right edge past r2 left\n      r1.x <= r2.x + r2.width - margin && // r1 left edge past r2 right\n      r1.y + r1.height - margin >= r2.y && // r1 top edge past r2 bottom\n      r1.y <= r2.y + r2.height - margin) {\n        // r1 bottom edge past r2 top\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"gameLoop\",\n    value: function gameLoop() {\n      var _this5 = this;\n\n      this.bgSprite.tilePosition.x -= 0.5;\n      this.floorSprite.tilePosition.x -= 0.8;\n\n      if (!this.isGameOver) {\n        this.player.update();\n\n        if (this.ghost) {\n          this.ghost.update(this.obstacles, this.players);\n        }\n\n        for (var remotePlayer in this.players) {\n          this.players[remotePlayer].update();\n        }\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.obstacles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var obs = _step2.value;\n            //Move the obstacle\n            obs.x -= 3; //Remove the obstacle if it's off screen\n\n            if (obs.x < 0 - obs.width) {\n              this.container.removeChild(obs);\n              this.obstacles.splice(this.obstacles.indexOf(obs), 1);\n              obs.destroy();\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this.detectCollision();\n      } else {\n        //Move score text\n        if (this.scoreText.steps) {\n          this.scoreText.x += this.scoreText.vx;\n          this.scoreText.y += this.scoreText.vy;\n          this.scoreText.style.fontSize += this.scoreText.vfs;\n          this.scoreText.steps -= 1;\n        }\n      }\n\n      requestAnimationFrame(function () {\n        return _this5.gameLoop();\n      });\n    }\n  }, {\n    key: \"detectCollision\",\n    value: function detectCollision() {\n      var collision = false;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.obstacles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var obs = _step3.value;\n          //detect collision\n          var obsBounds = obs.getBounds();\n          var playerBounds = this.player.sprite.getBounds();\n\n          if (this.collide(obsBounds, playerBounds)) {\n            collision = true;\n            break;\n          } else if (!obs.counted && obsBounds.x + obs.width < playerBounds.x + 1) {\n            //Score if the user overcomes the obstacle\n            var extraScore = Math.round(obsBounds.x / this.options.width * 2) * 5;\n            var newScore = 10 + extraScore;\n            this.score += newScore;\n            this.scoreText.text = this.score;\n            this.showTempScore(playerBounds, newScore);\n            obs.counted = true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (collision) {\n        this.gameOver();\n      }\n    }\n  }, {\n    key: \"showTempScore\",\n    value: function showTempScore(bounds, score) {\n      var opts = {\n        fontFamily: 'pixellari',\n        fontSize: 12,\n        fill: ['#00ff99']\n      };\n      var tempScore = new PIXI.Text(score, opts);\n      tempScore.x = bounds.x;\n      tempScore.y = bounds.y - 10;\n      this.container.addChild(tempScore);\n      setTimeout(function () {\n        tempScore.destroy();\n      }, 400);\n    }\n  }, {\n    key: \"gameOver\",\n    value: function gameOver() {\n      this.isGameOver = true;\n      this.channel.push('die', {});\n      this.player.die();\n      this.channelUnsubscribe(); //Set vx,vy and vfs to animate the scoreText to the center of screen\n\n      var targetPosition = {\n        x: this.options.width / 2,\n        y: this.options.height / 2\n      };\n      var steps = this.scoreText.steps = 20;\n      this.scoreText.vx = (targetPosition.x - this.scoreText.x) / steps;\n      this.scoreText.vy = (targetPosition.y - this.scoreText.y) / steps;\n      var fontSizeTarget = 50;\n      this.scoreText.vfs = (fontSizeTarget - this.scoreText.style.fontSize) / steps;\n      this.scoreText.anchor.set(0.5);\n      this.scoreText.style.align = 'center';\n\n      for (var player in this.players) {\n        this.players[player].destroy();\n        delete this.players[player];\n      }\n\n      this.gameResetText = new PIXI.Text('PRESS ENTER TO RESTART', {\n        fontFamily: 'pixellari',\n        fontSize: 15,\n        fill: ['#ffffff'],\n        align: 'center'\n      });\n      this.gameResetText.anchor.set(0.5);\n      this.gameResetText.x = this.options.width / 2;\n      this.gameResetText.y = 300;\n      this.container.addChild(this.gameResetText);\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      var _this6 = this;\n\n      if (this.isGameOver) {\n        this.channel.push('rejoin', {\n          character: this.character\n        }).receive('ok', function (state) {\n          _this6.resetGameState();\n\n          _this6.player.setInitialState();\n\n          if (_this6.ghost) _this6.ghost.setInitialState();\n          _this6.isGameOver = false;\n\n          _this6.onConnected(state);\n\n          _this6.channelSubscribe();\n        });\n      }\n    }\n  }, {\n    key: \"sendKey\",\n    value: function sendKey(key) {\n      if (this.isGameOver) {\n        return;\n      } //Send the key action to be processed and broadcasted by the server\n\n\n      this.channel.push('action', {\n        key: key,\n        x: this.player.position.x,\n        score: this.score\n      });\n    }\n  }]);\n\n  return Game;\n}();\n\n//# sourceURL=webpack:///./js/game.js?");

/***/ }),

/***/ "./js/ghost.js":
/*!*********************!*\
  !*** ./js/ghost.js ***!
  \*********************/
/*! exports provided: Ghost */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Ghost\", function() { return Ghost; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Ghost player.\n// This class mimics another player when there is only one player connected in the game\nvar Ghost =\n/*#__PURE__*/\nfunction () {\n  function Ghost(channel) {\n    _classCallCheck(this, Ghost);\n\n    this.ghostNames = ['Copper', 'Radius', 'Wire', 'Technamic', 'Extreme Travel Bot'];\n    this.channel = channel;\n    this.character = 'ninjafrog';\n    var nameIndex = randomNumber(0, this.ghostNames.length - 1);\n    this.username = this.ghostNames[nameIndex];\n    this.channel.push('start_ghost', {\n      ghost_name: this.username,\n      character: this.character\n    });\n    this.setInitialState();\n  }\n\n  _createClass(Ghost, [{\n    key: \"setInitialState\",\n    value: function setInitialState() {\n      this.score = 0;\n    }\n  }, {\n    key: \"update\",\n    value: function update(obstacles, players) {\n      var _this = this;\n\n      var ghostPlayer = players[this.username];\n      var obs = obstacles.filter(function (x) {\n        return !x.skipped;\n      })[0];\n\n      if (obs) {\n        var obsBounds = obs.getBounds();\n        var playerBounds = ghostPlayer.sprite.getBounds();\n        var distance = obsBounds.x - playerBounds.x; // If ghost is moving right closer to obstacle, update vx to move forward\n\n        if (distance < 120 && ghostPlayer.vx < 0) {\n          ghostPlayer.vx = 1;\n        } else {\n          this.updateVx(ghostPlayer);\n        }\n\n        if (!obs.skipped && distance < 80) {\n          obs.skipped = true;\n          this.score += 10;\n          this.channel.push('ghost_action', {\n            key: 'up.press',\n            x: 0,\n            score: this.score\n          });\n          setTimeout(function () {\n            _this.channel.push('ghost_action', {\n              key: 'up.release',\n              x: 0,\n              score: _this.score\n            });\n          }, 200);\n        }\n      }\n    }\n  }, {\n    key: \"updateVx\",\n    value: function updateVx(player) {\n      this.waitFor(randomNumber(1000, 3000), function () {\n        var fromRight = player.bounds.right - player.sprite.x;\n        var fromLeft = player.sprite.x - player.bounds.left;\n        var minVx = -2;\n        var maxVx = 2; // If player is on the right, aim to move it to the left\n\n        if (fromRight < 150) {\n          maxVx = 0; // If player is on the left, aim to move it to the right\n        } else if (fromLeft < 100) {\n          minVx = 0;\n        }\n\n        if (player.onFloor()) {\n          player.vx = randomNumber(minVx, maxVx);\n        }\n      });\n    }\n  }, {\n    key: \"waitFor\",\n    value: function waitFor(millis, then) {\n      var _this2 = this;\n\n      if (!this.waitHandler) {\n        this.waitHandler = setTimeout(function () {\n          then();\n          _this2.waitHandler = undefined;\n        }, millis);\n      }\n    }\n  }]);\n\n  return Ghost;\n}();\n\nfunction randomNumber(min, max) {\n  return Math.ceil(Math.random() * (max - min) + min);\n}\n\n//# sourceURL=webpack:///./js/ghost.js?");

/***/ }),

/***/ "./js/keyboard.js":
/*!************************!*\
  !*** ./js/keyboard.js ***!
  \************************/
/*! exports provided: keyboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keyboard\", function() { return keyboard; });\nfunction keyboard(value) {\n  var key = {};\n  key.value = value;\n  key.isDown = false;\n  key.isUp = true;\n  key.press = undefined;\n  key.release = undefined; //The `downHandler`\n\n  key.downHandler = function (event) {\n    if (event.key === key.value) {\n      if (key.isUp && key.press) key.press();\n      key.isDown = true;\n      key.isUp = false;\n      event.preventDefault();\n    }\n  }; //The `upHandler`\n\n\n  key.upHandler = function (event) {\n    if (event.key === key.value) {\n      if (key.isDown && key.release) key.release();\n      key.isDown = false;\n      key.isUp = true;\n      event.preventDefault();\n    }\n  }; //Attach event listeners\n\n\n  var downListener = key.downHandler.bind(key);\n  var upListener = key.upHandler.bind(key);\n  window.addEventListener(\"keydown\", downListener, false);\n  window.addEventListener(\"keyup\", upListener, false); // Detach event listeners\n\n  key.unsubscribe = function () {\n    window.removeEventListener(\"keydown\", downListener);\n    window.removeEventListener(\"keyup\", upListener);\n  };\n\n  return key;\n}\n\n//# sourceURL=webpack:///./js/keyboard.js?");

/***/ }),

/***/ "./js/player.js":
/*!**********************!*\
  !*** ./js/player.js ***!
  \**********************/
/*! exports provided: Player */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Player\", function() { return Player; });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Player =\n/*#__PURE__*/\nfunction () {\n  function Player(spriteSheet, container, options) {\n    _classCallCheck(this, Player);\n\n    this.spriteSheet = spriteSheet;\n    this.sprites = {};\n    var gap = 20;\n    this.speed = 2;\n    this.gravity = 0.3;\n    this.bounds = {\n      top: gap,\n      left: gap,\n      bottom: options.height - 50,\n      right: options.width - gap\n    };\n    this.parentContainer = container;\n    this.playerContainer = new PIXI.Container();\n    this.loadSprites(spriteSheet);\n    this.parentContainer.addChild(this.playerContainer);\n    this.state = {};\n    this.floor = this.bounds.bottom - this.sprite.height / 2;\n\n    this.onJumpFinished = function () {};\n\n    this.dead = false;\n  }\n\n  _createClass(Player, [{\n    key: \"loadSprites\",\n    value: function loadSprites(spriteSheet) {\n      var animations = ['idle', 'run', 'walljump', 'hit', 'jump', 'fall', 'doublejump'];\n\n      for (var _i = 0, _animations = animations; _i < _animations.length; _i++) {\n        var anim = _animations[_i];\n        //Create the pixi animated sprite for each animation\n        this.sprites[anim] = new PIXI.AnimatedSprite(spriteSheet.animations[anim]);\n        this.sprites[anim].id = anim;\n        this.sprites[anim].anchor.set(0.5);\n        this.sprites[anim].visible = false;\n        this.sprites[anim].animationSpeed = 0.3;\n        this.playerContainer.addChild(this.sprites[anim]);\n      }\n\n      this.sprite = this.sprites['idle'];\n      this.setInitialState();\n    }\n  }, {\n    key: \"setInitialState\",\n    value: function setInitialState() {\n      this.vy = 0;\n      this.vx = 0;\n      this.jumping = false; //Load the default animation\n\n      this.switchToSprite('idle');\n      this.sprite.visible = true;\n      this.sprite.y = this.bounds.bottom - this.sprite.height / 2;\n      this.sprite.x = 90;\n      this.sprite.play();\n      this.dead = false;\n    }\n  }, {\n    key: \"setTransparency\",\n    value: function setTransparency() {\n      this.sprite.alpha = 0.4;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dead) {\n        return;\n      }\n\n      var newXPosition = this.sprite.x + this.vx;\n\n      if (newXPosition > this.bounds.left && newXPosition < this.bounds.right) {\n        this.sprite.x = newXPosition;\n      }\n\n      this.sprite.y = this.constrain(this.sprite.y + this.vy, this.bounds.top, this.floor);\n      var wasJumping = this.vy !== 0;\n      this.vy += this.gravity; //If the sprite is a floor level, stop y velocity\n\n      if (this.onFloor()) {\n        this.vy = 0;\n\n        if (wasJumping) {\n          this.onJumpFinished(); //Stop x velocity if no direction is given (no left-right key is pressed)\n\n          if (!this.direction) {\n            this.vx = 0;\n          } else {\n            this.vx = this.direction == \"right\" ? this.speed : -this.speed;\n          }\n        }\n\n        if (this.vx !== 0) {\n          this.switchToSprite(\"run\");\n        } else {\n          this.switchToSprite(\"idle\");\n        }\n      } else if (this.vy > 0) {\n        //check if it is going down to change the animation (vy is positive)\n        this.switchToSprite(\"fall\");\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(state) {\n      this.state = state;\n\n      var _this$state$move$spli = this.state.move.split('.'),\n          _this$state$move$spli2 = _slicedToArray(_this$state$move$spli, 2),\n          key = _this$state$move$spli2[0],\n          action = _this$state$move$spli2[1]; //Switch sprite animations based on key action\n      //and change speed in x or y axis\n\n\n      if (state.move == \"up.press\" && this.onFloor()) {\n        //Only can jump if on the floor\n        this.vy = -7;\n        this.switchToSprite('jump');\n      } else if (key == \"right\" || key == \"left\") {\n        if (action == \"press\") {\n          this.direction = key; //Flips sprite vertically \n\n          this.sprite.scale.x = this.direction == \"left\" ? -1 : 1; //If when not on the floor, it can't move horizontally\n\n          if (this.onFloor()) {\n            this.vx = key == \"right\" ? this.speed : -this.speed;\n          } //Even when not on the floor, the body still can move though\n\n\n          this.switchToSprite('run');\n        } else {\n          //If the release was on the same last key pressed\n          if (this.direction == key) {\n            if (this.onFloor()) {\n              //Only stop moving if on the floor\n              //otherwise will stop when the jump finishes\n              this.vx = 0;\n              this.switchToSprite('idle');\n            }\n\n            this.direction = \"\";\n          }\n        }\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.parentContainer.removeChild(this.playerContainer);\n      this.playerContainer.destroy({\n        childred: true\n      });\n    }\n  }, {\n    key: \"constrain\",\n    value: function constrain(n, low, high) {\n      return Math.max(Math.min(n, high), low);\n    }\n  }, {\n    key: \"onFloor\",\n    value: function onFloor() {\n      return this.sprite.y == this.floor;\n    }\n  }, {\n    key: \"switchToSprite\",\n    value: function switchToSprite(key) {\n      if (this.sprite.id == key || this.dead) {\n        return;\n      }\n\n      this.sprite.stop();\n      this.sprite.visible = false;\n      this.previous = this.sprite;\n      this.sprite = this.sprites[key];\n      this.sprite.x = this.previous.x;\n      this.sprite.y = this.previous.y;\n      this.sprite.scale.x = this.previous.scale.x;\n      this.sprite.alpha = this.previous.alpha;\n      this.sprite.visible = true;\n      this.sprite.play();\n    }\n  }, {\n    key: \"die\",\n    value: function die() {\n      this.switchToSprite('hit');\n      this.dead = true;\n    }\n  }, {\n    key: \"dieAndTint\",\n    value: function dieAndTint() {\n      this.die();\n      this.sprite.tint = 0xf22059;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return {\n        x: this.sprite.x,\n        y: this.sprite.y\n      };\n    }\n  }, {\n    key: \"x\",\n    set: function set(value) {\n      this.sprite.x = value;\n    }\n  }]);\n\n  return Player;\n}();\n\n//# sourceURL=webpack:///./js/player.js?");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./js/app.js */\"./js/app.js\");\n\n\n//# sourceURL=webpack:///multi_./js/app.js?");

/***/ })

/******/ });